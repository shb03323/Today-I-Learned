# 제네릭

- 제네릭의 의미
    - 타입을 마치 함수의 파라미터처럼 사용하는 것
        
        ```tsx
        function getText(text) {
          return text;
        }
        
        getText('hi');  // 'hi'
        getText(10);  // 10
        getText(true);  // true
        ```
        
    - 제네릭 기본 문법
        
        ```tsx
        function getText<T>(text: T): T {
          return text;
        }
        
        getText<string>('hi');
        getText<number>(10);
        getText<boolean>(true);
        ```
        
- 제네릭을 사용하는 이유
    - 여러가지 타입을 허용하고 싶을 때 `any`를 사용할 수 있다.
        
        ```tsx
        function logText(text: any): any {
          return text;
        }
        ```
        
    - 함수의 인자로 어떤 타입이 들어갔고 어떤 값이 반환되는지 알 수 없다. `any`라는 타입은 타입 검사를 하지 않기 때문이다. 제네릭을 사용하면 함수를 호출할 때 넘긴 타입에 대해 추정할 수 있게 된다.
        
        ```tsx
        function logText<T>(text: T): T {
          return text;
        }
        ```
        
    - 호출할 땐 아래와 같은 2가지 방법으로 호출 가능
        
        ```tsx
        // #1
        const text = logText<string>("Hello Generic");
        // #2
        const text = logText("Hello Generic");
        ```
        
- 제네릭 타입 변수
    - 특정 타입에만 있는 확장함수를 사용하게 되면 에러가 발생한다.
        
        ```tsx
        function logText<T>(text: T): T {
          console.log(text.length);  // Error: T doesn't have .length
          return text;
        }
        ```
        
    - 제네릭에 타입을 주는 방법으로 해결할 수 있다.
        
        ```tsx
        // #1
        function logText<T>(text: T[]): T[] {
          console.log(text.length);  // 제네릭 타입이 배열이기 때문에 `length`를 허용
          return text;
        }
        
        // #2
        function logText<T>(text: Array<T>): Array<T> {
          console.log(text.length);
          return text;
        }
        ```
        
- 제네릭 타입
    - 변수 선언의 두 가지 방식
        
        ```tsx
        function logText<T>(text: T): T {
          return text;
        }
        // #1
        let str: <T>(text: T) => T = logText;
        // #2
        let str: {<T>(text: T): T} = logText;
        ```
        
    - 인터페이스 방식
        
        ```tsx
        interface GenericLogTextFn<T> {
          (text: T): T;
        }
        function logText<T>(text: T): T {
          return text;
        }
        let myString: GenericLogTextFn<string> = logText;
        ```
        
    - 제네릭 인터페이스 뿐만 아니라 클래스도 생성할 수 있다. 다만, 이넘과 네임스페이스는 제네릭으로 생성할 수 없다.
- 제네릭 클래스
    - 제네릭 클래스를 선언할 때 클래스 이름 오른쪽에 `<T>`를 붙여준다
        
        ```tsx
        // 제네릭 인터페이스
        interface IExport<T> {
            export(): T;
        }
         
        // 제네릭 클래스
        class MyData<T> implements IExport<T> {
            private _data: T;
         
            constructor(data: T) {
                this._data = data;
            }
         
            export(): T {
                let cloned  = Object.assign({}, this._data);
                return cloned;
            }
        }
         
        class Person { id: number; name: string; }
        let p: Person = {id: 1, name:"Tim" };
         
        let o = new MyData<Person>(p);
        let cp: Person = o.export();
        console.log(cp.name);
        ```
        
- 제네릭 제약 조건
    - 타입을 정의하지 않고 `length` 속성을 허용하는 방법
        
        ```tsx
        interface LengthWise {
          length: number;
        }
        
        function logText<T extends LengthWise>(text: T): T {
          console.log(text.length);
          return text;
        }
        
        logText(10);  // Error, 숫자 타입에는 `length`가 존재하지 않으므로 오류 발생
        logText({ length: 0, value: 'hi' });  // `text.length` 코드는 객체의 속성 접근과 같이 동작하므로 오류 없음
        ```

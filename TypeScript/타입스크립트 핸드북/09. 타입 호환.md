# 타입 호환

- 타입 호환 이란?
    - 타입스크립트 코드에서 특정 타입이 다른 타입에 잘 맞는지를 의미한다.
        
        ```tsx
        interface Ironman {
          name: string;
        }
        
        class Avengers {
          name: string;
        }
        
        let i: Ironman;
        i = new Avengers();  
        // OK, because of structural typing
        ```
        
- 구조적 타이핑 예시
    - 구조적 타이핑(Structural typing)이란 코드 구조 관점에서 타입이 서로 호환되는지의 여부를 판단하는 것이다.
        
        ```tsx
        interface Avengers {
          name: string;
        }
        
        let hero: Avengers;
        let capt = { name: "Captain", location: "Pangyo" };
        hero = capt;
        // 타입스크립트가 추론한 hero의 타입은 { name: string; location: string; }
        // `capt`의 속성 중에 `name`이 있기 때문에 `capt`는 `Avengers`타입에 호환 가능
        
        // 함수 호출 시에도 마찬가지
        function assemble(a: Avengers) {
          console.log("어벤져스 모여라", a.name);
        }
        assemble(capt);
        // `capt` 변수에 이미 `name` 속성 뿐만 아니라 `location` 속성도 있기 때문에 `assemble`함수의 호출 인자로 넘기기 가능
        ```
        
- Soundness
    - 타입스크립트는 컴파일 시점에 타입을 추론할 수 없는 특정 타입에 대해 일단 안전하다고 보는 특성이 있는데, 이걸 Soundness라고 표현한다.
- 타입 호환 주의 사항
    - Enum : `number`타입과 호환되지만 `enum`타입 끼리는 호환되지 않는다.
        
        ```tsx
        enum Status { Ready, Waiting };
        enum Color { Red, Blue, Green };
        
        let status = Status.Ready;
        status = Color.Green;  // Error
        ```
        
    - Class : 클래스 타입끼리 비교할 때 스태틱 맴버와 생성자를 제외하고 속성만 비교한다.
        
        ```tsx
        class Hulk {
          handSize: number;
          constructor(name: string, numHand: number) { }
        }
        
        class Captain {
          handSize: number;
          constructor(numHand: number) { }
        }
        
        let a: Hulk;
        let s: Captain;
        
        a = s;  // OK
        s = a;  // OK
        ```
        
- Generics
    - 제네릭 타입 간의 호환 여부를 판단할 때 타입 인자 `<T>`가 속성에 할당 되었는지를 기준으로 한다.
        
        ```tsx
        interface Empty<T> {
        }
        let x: Empty<number>;
        let y: Empty<string>;
        
        x = y;  // OK
        // 인터페이스에 속성이 없기 때문에 같은 타입으로 간주
        
        interface NotEmpty<T> {
          data: T;
        }
        let x: NotEmpty<number>;
        let y: NotEmpty<string>;
        
        x = y;  // Error
        // 인터페이스에 넘긴 제네릭 타입이 `data`속성에 할당되었으므로 `x`와 `y`는 서로 다른 타입으로 간주
        ```

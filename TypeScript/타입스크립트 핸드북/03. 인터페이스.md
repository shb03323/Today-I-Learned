# 인터페이스

- 인터페이스 기초
    - 인터페이스 적용 전
        
        ```tsx
        let person = { name: 'Capt', age: 28 };
        
        function logAge(obj: { age: number }) {
          console.log(obj.age);  // 28
        }
        logAge(person);  // 28
        ```
        
    - 인터페이스 적용 후
        
        ```tsx
        interface personAge {
          age: number;
        }
        
        function logAge(obj: personAge) {
          console.log(obj.age);
        }
        let person = { name: 'Capt', age: 28 };  // 인터페이스의 속성 개수와 인자로 받는 객체의 속성 개수를 일치시키지 않아도 됨
        logAge(person);
        ```
        
- 옵션 속성
    - 인터페이스를 사용할 때 인터페이스에 정의되어 있는 속성을 모두 다 꼭 사용하지 않아도 된다. 이를 옵션 속성이라고 한다. 정의할 땐, 속성의 끝에 `?`를 붙이면 된다.
        
        ```tsx
        interface CraftBeer {
          name: string;
          hop?: number;  
        }
        
        let myBeer = {
          name: 'Cass'
        };
        function brewBeer(beer: CraftBeer) {
          console.log(beer.name);  // Cass
        }
        brewBeer(myBeer);  // Cass
        ```
        
    - 옵션 속성은 단순히 인터페이스를 사용할 때 속성을 선택적으로 적용할 수 있을 뿐만 아니라 인터페이스에 정의되어 있지 않은 속성에 대해서 인지시켜줄 수도 있다.
        
        ```tsx
        interface CraftBeer {
          name: string;
          hop?: number;
        }
        
        function brewBeer(beer: CraftBeer) {
          console.log(beer.nam);  // Error: Property 'nam' does not exist on type 'Beer'
        }
        ```
        
- 읽기 전용 속성
    - 인터페이스로 객체를 처음 생성할 때만 값을 할당하고 그 이후에는 변경할 수 없는 속성을 의미한다.
    - `readonly`를 변수명 앞에 붙인다.
        
        ```tsx
        interface CraftBeer {
          readonly brand: string;
        }
        
        let myBeer: CraftBeer = {
          brand: 'Belgian Monk'
        };
        myBeer.brand = 'Korean Carpenter';  // error!
        ```
        
- 읽기 전용 배열
    - 배열을 선언할 때 `ReadonlyArray<T>` 타입을 사용하면 읽기 전용 배열을 생성할 수 있다.
        
        ```tsx
        let arr: ReadonlyArray<number> = [1,2,3];
        arr.splice(0,1);  // error
        arr.push(4);  // error
        arr[0] = 100;  // error
        ```
        
- 객체 선언과 관련된 타입 체킹
    - 타입 추론을 무시하고 싶은 경우 `as`를 활용한다.
        
        ```tsx
        interface CraftBeer {
          brand?: string;
        }
        
        function brewBeer(beer: CraftBeer) {
          // ..
        }
        
        ****let myBeer = { brand: 'what' }';
        brewBeer(myBeer as CraftBeer);
        ```
        
    - 인터페이스 정의하지 않은 속성들을 추가로 사용하고 싶은 경우
        
        ```tsx
        interface CraftBeer {
          brand?: string;
          [propName: string]: any;
        }
        ```
        
- 함수 타입
    
    ```tsx
    interface login {  // 정의
      (id: string, pw: string): boolean;
    }
    
    let loginUser: login;
    loginUser = function(id: string, pw: string) {  // 사용
      console.log('로그인 했습니다');
      return true;
    }
    ```
    
- 클래스 타입
    
    ```tsx
    interface CraftBeer {
      beerName: string;
      nameBeer(beer: string): void;
    }
    
    class myBeer implements CraftBeer {
      beerName: string = 'Baby Guinness';
      nameBeer(b: string) {
        this.beerName = b;
      }
      constructor() {}
    }
    ```
    
- 인터페이스 확장
    - 인터페이스 간 확장
        
        ```tsx
        interface Person {
          name: string;
        }
        interface Developer extends Person {
          skill: string;
        }
        let fe = {} as Developer;
        fe.name = 'josh';
        fe.skill = 'TypeScript';
        ```
        
    - 여러 인터페이스 상속
        
        ```tsx
        interface Person {
          name: string;
        }
        interface Drinker {
          drink: string;
        }
        interface Developer extends Person, Drinker {
          skill: string;
        }
        let fe = {} as Developer;
        fe.name = 'josh';
        fe.skill = 'TypeScript';
        fe.drink = 'Beer';
        ```
        
- 하이브리드 타입
    - 자바스크립트의 유연하고 동적인 타입 특성에 따라 인터페이스 역시 여러가지 타입을 조합하여 만들 수 있다.
        
        ```tsx
        interface CraftBeer {
          (beer: string): string;
          brand: string;
          brew(): void;
        }
        
        function myBeer(): CraftBeer {
          let my = (function(beer: string) {}) as CraftBeer;
          my.brand = 'Beer Kitchen';
          my.brew = function() {};
          return my;
        }
        
        let brewedBeer = myBeer();
        brewedBeer('My First Beer');
        brewedBeer.brand = 'Pangyo Craft';
        brewedBeer.brew();
        ```
